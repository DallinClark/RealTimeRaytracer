#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

layout(set = 0, binding = 0, rgba32f) uniform image2D image; // image, holds pixels for the output
layout(set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

struct GPUCameraData { // recreate camera details
    vec3 position;
    vec3 topLeftViewportCorner;
    vec3 horizontalViewportDelta;
    vec3 verticalViewportDelta;
};

layout(set = 0, binding = 2) uniform CameraUBO {
    GPUCameraData cam;
};

layout(location = 0) rayPayloadEXT vec3 payload; // payload to pass into hit/miss shader

// --------------- Hard coded origin, replace with camera logic
vec34 origin = {0, 0, -2, 1};

void main() {
    ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    ivec2 resolution = imageSize(image);
    vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / vec2(resolution); // pixel center

    // Compute pixel's world position on the image plane
    vec3 pixelWorldPos =
        cam.topLeftViewportCorner +
        uv.x * cam.horizontalViewportDelta +
        uv.y * cam.verticalViewportDelta;

    // Perspective ray: from camera position toward pixel on viewport
    // ---------------- Replace with camera position once implemented
    vec3 rayOrigin = origin;
    vec3 rayDirection = normalize(pixelWorldPos - cam.position);

    // Initialize the payload
    payload = vec3(0.0);

    // Shoot the ray
    traceRayEXT(
        topLevelAS,
        gl_RayFlagsOpaqueEXT,
        0xFF,
        0, 0, 0,
        rayOrigin, 0.001,
        rayDirection, 10000.0,
        0
    );

    imageStore(image, pixelCoord, vec4(payload, 1.0));
}