#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"
#include "cook-torrance.glsl"

const uint NUM_PRIMARY_RAYS = 1u;

layout(set = 0, binding = 0, rgba8) uniform image2D finalImage;
layout(set = 0, binding = 1) uniform accelerationStructureEXT topLevelAS;

layout(set = 0, binding = 2) uniform CameraUBO {
    GPUCameraData cam;
};

layout( push_constant ) uniform constants
{
    uint frame;
    uint numLights;
    uint _pad0;
    uint _pad1;
    vec3 camPosition;
    float padding_;
} sceneData;

layout(set = 0, binding = 3) readonly buffer VertexBuffer {
    Vertex vertices[];
};
layout(set = 0, binding = 5) uniform sampler2D texSamplers[];
layout(set = 0, binding = 6) readonly buffer ObjectInfoBuffer {
    ObjectInfo objectInfos[];
};
layout(set = 0, binding = 7) readonly buffer LightInfoBuffer {
    LightInfo lightInfos[];
};

layout(location = 0) rayPayloadEXT HitInfo payload;
layout(location = 1) rayPayloadEXT bool isShadowed;

const float LUT_SIZE  = 64.0;
const float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;
const float LUT_BIAS  = 0.5/LUT_SIZE;

#include "LTC.glsl"

void main() {
    vec3 hitNormal = vec3(0.0);

    const ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    vec3 accumulatedColor = vec3(0.0);

    for (uint i = 0; i < NUM_PRIMARY_RAYS; i++) {
        //jitter ray target within each pixel
        vec2 jitter = vec2(random(int(pixelCoord + i)), random(int(pixelCoord + i*322)));
        vec2 pixelOffset = (vec2(pixelCoord) + jitter) - vec2(0.5);

        const vec3 pixelWorldPos =
            cam.topLeftViewportCorner +
            pixelOffset.x * cam.horizontalViewportDelta +
            pixelOffset.y * cam.verticalViewportDelta;

        const vec3 rayOrigin = cam.position;
        const vec3 rayDirection = normalize(pixelWorldPos - rayOrigin);

        payload.hitPoint        = vec3(0.0);
        payload.normal          = vec3(0.0);
        payload.uv              = vec2(0.0);
        payload.objectInfoIndex = 0;
        payload.hitLight        = 0;
        payload.missed          = 0;

        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0, 0, 0,
            rayOrigin, 0.001,
            rayDirection, 10000.0,
            0
        );
        if (payload.missed == 1) {
            accumulatedColor += vec3(0.0);
        }

        if (payload.hitLight == 1) {
            accumulatedColor += payload.normal;
            continue;
        }

        ObjectInfo objectInfo = objectInfos[payload.objectInfoIndex];
        vec3 hitPoint         = payload.hitPoint;
        hitNormal             = payload.normal;
        vec3 viewDir          = normalize(sceneData.camPosition - hitPoint);
        vec2 uv               = payload.uv;

        // Get material info
        float roughness = 0.0;
        float metallic = 0.0;
        vec3 surfaceColor = vec3(0.0);

        if (objectInfo.usesColorMap != 0) {
              surfaceColor = texture(nonuniformEXT(texSamplers[objectInfo.colorIndex]), uv).rgb;
        } else {
            surfaceColor = objectInfo.color;
        }

        if (objectInfo.usesSpecularMap != 0) {
            roughness = texture(nonuniformEXT(texSamplers[objectInfo.specularIndex]), uv).r;
        } else {
            roughness = objectInfo.specular;
        }

        if (objectInfo.usesMetallicMap != 0) {
            metallic = texture(nonuniformEXT(texSamplers[objectInfo.metallicIndex]), uv).r;
        } else {
            metallic = objectInfo.metallic;
        }

        // The contribution from diffuse and specular
        vec3 mDiffuse = (1.0 - metallic) * surfaceColor;
        vec3 mSpecular = mix(vec3(0.04), surfaceColor, metallic);

        vec3 N = hitNormal;
        vec3 V = viewDir;
        vec3 P = hitPoint;
        float dotNV = clamp(dot(hitNormal, viewDir), 0.0f, 1.0f);

        // use roughness and sqrt(1-cos_theta) to sample M_texture
        vec2 LUTuv = vec2(roughness, sqrt(1.0f - dotNV));
        LUTuv = LUTuv*LUT_SCALE + LUT_BIAS;

        // get 4 parameters for inverse_M
        vec4 t1 = texture(nonuniformEXT(texSamplers[0]), LUTuv);

        // Get 2 parameters for Fresnel calculation
        vec4 t2 = texture(nonuniformEXT(texSamplers[1]), LUTuv);

        mat3 Minv = mat3(
            vec3(t1.x, 0, t1.y),
            vec3(  0,  1,    0),
            vec3(t1.z, 0, t1.w)
        );

        vec3 result = vec3(0.0);
        vec3 specular = vec3(0.0);
        vec3 diffuse = vec3(0.0);

        // loop through the lights to see their color contribution
        for (uint i = 0; i < sceneData.numLights; ++i) {
           LightInfo currLight = lightInfos[i];

           uint lightVertexOffset = currLight.vertexOffset;

           Vertex lv0 = vertices[lightVertexOffset + 0];
           Vertex lv1 = vertices[lightVertexOffset + 1];
           Vertex lv2 = vertices[lightVertexOffset + 2];
           Vertex lv3 = vertices[lightVertexOffset + 3];

           mat4 lightTransform = currLight.transform;

           vec3 translatedPoints[4];
           translatedPoints[0] = (lightTransform * vec4(lv0.position, 1.0)).xyz;
           translatedPoints[1] = (lightTransform * vec4(lv1.position, 1.0)).xyz;
           translatedPoints[2] = (lightTransform * vec4(lv2.position, 1.0)).xyz;
           translatedPoints[3] = (lightTransform * vec4(lv3.position, 1.0)).xyz;

           const uint numShadowSamples = 4;
           float shadowFactor = 0.0;

           vec3 shadowedSampleColor   = vec3(0.0);
           vec3 unshadowedSampleColor = vec3(0.0);

           // cast shadow rays
           for (uint s = 0; s < numShadowSamples; ++s) {
               // Compute shadow ray direction towards some point on the area light
               // For now, just pick a simple center or random point on the light
               uvec2 pixel = gl_LaunchIDEXT.xy;
               uint seed = s + pixel.x * 733 + pixel.y * 1933 + sceneData.frame;
               float r1 = random(seed);
               float r2 = random(seed + 100);

               bool useSecondTriangle = (random(s + 64) > 0.5);

               vec3 lightSamplePos = vec3(0.0);

               if (!useSecondTriangle) {
                   // Triangle 1: translatedPoints[0], translatedPoints[1], translatedPoints[2]
                   if (r1 + r2 > 1.0) {
                       r1 = 1.0 - r1;
                       r2 = 1.0 - r2;
                   }
                   lightSamplePos = translatedPoints[0] + r1 * (translatedPoints[1] - translatedPoints[0]) + r2 * (translatedPoints[2] - translatedPoints[0]);
               } else {
                       // Triangle 2: translatedPoints[0], translatedPoints[2], translatedPoints[3]
                       if (r1 + r2 > 1.0) {
                           r1 = 1.0 - r1;
                           r2 = 1.0 - r2;
                       }
                       lightSamplePos = translatedPoints[0] + r1 * (translatedPoints[2] - translatedPoints[0]) + r2 * (translatedPoints[3] - translatedPoints[0]);
               }


               vec3 sampledLightDir = normalize(lightSamplePos - hitPoint);
               float lightDistance = length(lightSamplePos - hitPoint);

               vec3 shadowRayOrigin = hitPoint + hitNormal * 0.01;

               // Reset shadow payload before trace
               isShadowed = true;

               uint shadowFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;

               traceRayEXT(
                   topLevelAS,
                   shadowFlags,
                   0xFF,
                   0, 0, 1,
                   shadowRayOrigin,
                   0.001,
                   sampledLightDir,
                   lightDistance - 0.5,
                   1 // location of shadow ray payload
               );

               // if any hit, isShadowed will be true, so shadowFactor only adds when not shadowed
               float currShadow = isShadowed ? 0.0 : 1.0;
               shadowFactor += currShadow;

               vec3 halfVector = normalize(viewDir + sampledLightDir);

               vec3 F0 = mSpecular;
               float cosTheta = clamp(dot(viewDir, halfVector), 0.0, 1.0);

               float D = GGX_Distribution(hitNormal, halfVector, roughness);
               float G = GGX_PartialGeometryTerm(viewDir, hitNormal, halfVector, roughness) * GGX_PartialGeometryTerm(sampledLightDir, hitNormal, halfVector, roughness);
               vec3 F = Fresnel_Schlick(cosTheta, F0);

               float NdotV = max(dot(hitNormal, viewDir), 0.0001);
               float NdotL = max(dot(hitNormal, sampledLightDir), 0.0001);

               vec3 currSpecular = (D * F * G) / (4.0 * NdotV * NdotL);
               vec3 currDiffuse = (1.0 - metallic) * surfaceColor / PI; // Lambert diffuse term

               vec3 lightVec = lightSamplePos - hitPoint;
               float distance = length(lightVec);
               float attenuation = 1.0 / (distance * distance);

               vec3 BRDF = currSpecular + currDiffuse;
               vec3 L = currLight.color * currLight.intensity * NdotL * attenuation;

                shadowedSampleColor   += currShadow * BRDF * L;
                unshadowedSampleColor += BRDF * L;
           }
           shadowedSampleColor   /= float(numShadowSamples);
           unshadowedSampleColor /= float(numShadowSamples);

           shadowFactor /= float(numShadowSamples);

           bool twoSided = true;

           diffuse = LTC_Evaluate(N, V, P, mat3(1), translatedPoints, twoSided);
           specular = LTC_Evaluate(N, V, P, Minv, translatedPoints, twoSided);

           vec3 fresnel = mSpecular * t2.x + (vec3(1.0) - mSpecular) * t2.y;
           specular *= fresnel;

           accumulatedColor += currLight.color * currLight.intensity * (specular + mDiffuse * diffuse) * (shadowedSampleColor / unshadowedSampleColor);
       }
    }

    accumulatedColor = hitNormal;// /= float(NUM_PRIMARY_RAYS);

    imageStore(finalImage, pixelCoord, vec4(accumulatedColor.b, accumulatedColor.g, accumulatedColor.r, 1.0));
}
